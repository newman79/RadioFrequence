/*
Cette page récupere les informations du signal radio recu par le raspberry PI et execute une page PHP en lui fournissant tout les paramêtres.

Vous pouvez compiler cette source via la commande :
	g++ radioReception.cpp -o radioReception -lwiringPi
		
	N'oubliez pas d'installer auparavant la librairie wiring pi ainsi que l'essentiel des paquets pour compiler

Vous pouvez lancer le programme via la commande :
	sudo chmod 777 radioReception
	./radioReception /var/www/radioReception/radioReception.php  7

	Les deux parametres de fin étant le chemin vers le PHP a appeller, et le numéro wiringPi du PIN relié au récepteur RF 433 mhz
	
@author : Valentin CARRUESCO (idleman@idleman.fr)
@contributors : Yann PONSARD, Jimmy LALANDE
@webPage : http://blog.idleman.fr
@references & Libraries: https://projects.drogon.net/raspberry-pi/wiringpi/, http://playground.arduino.cc/Code/HomeEasy
@licence : CC by sa (http://creativecommons.org/licenses/by-sa/3.0/fr/)
RadioPi de Valentin CARRUESCO (Idleman) est mis à disposition selon les termes de la 
licence Creative Commons Attribution - Partage dans les Mêmes Conditions 3.0 France.
Les autorisations au-delà du champ de cette licence peuvent être obtenues à idleman@idleman.fr.
*/


#include <wiringPi.h>
#include <iostream>
#include <stdio.h>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <sched.h>
#include <sstream>

using namespace std;

//initialisation du pin de reception
int pin;

//Fonction de log
void log(string a){
	//Décommenter pour avoir les logs
	cout << a << endl;
}

//Fonction de conversion long vers string
string longToString(long mylong){
    string mystring;
    stringstream mystream;
    mystream << mylong;
    return mystream.str();
}

//Fonction de passage du programme en temps réel (car la reception se joue a la micro seconde près)
void scheduler_realtime() {
	struct sched_param p;
	p.__sched_priority = sched_get_priority_max(SCHED_RR);
	if( sched_setscheduler( 0, SCHED_RR, &p ) == -1 ) {
	perror("Failed to switch to realtime scheduler.");
	}
}

//Fonction de remise du programme en temps standard
void scheduler_standard() {
	struct sched_param p;
	p.__sched_priority = 0;
	if( sched_setscheduler( 0, SCHED_OTHER, &p ) == -1 ) {
	perror("Failed to switch to normal scheduler.");
	}
}

//Recuperation du temp (en micro secondes) d'une pulsation
int pulseInOrig(int pin, int level, int timeout)
{
   struct timeval tn, t0, t1;
   long micros;
   gettimeofday(&t0, NULL);
   micros = 0;
   while (digitalRead(pin) != level)
   {
      gettimeofday(&tn, NULL);
      if (tn.tv_sec > t0.tv_sec) micros = 1000000L; else micros = 0; // ca signifie qu'au moins 1 seconde s'est passée entre t0 et tn
      micros += (tn.tv_usec - t0.tv_usec);
      if (micros > timeout) return 0;
   }
   gettimeofday(&t1, NULL); // t1 est l'instant ou le signal arrive à level
   while (digitalRead(pin) == level)
   {
      gettimeofday(&tn, NULL);
      if (tn.tv_sec > t0.tv_sec) micros = 1000000L; else micros = 0; // ca signifie qu'au moins 1 seconde s'est passée entre t0 et tn
      micros = micros + (tn.tv_usec - t0.tv_usec);
      if (micros > timeout) return 0;
   }
   if (tn.tv_sec > t1.tv_sec) micros = 1000000L; else micros = 0; // je ne sais pas pourquoi il fait ça
   micros = micros + (tn.tv_usec - t1.tv_usec);		// ajout différence entre les instants t1 et tn --> durée pendant laquelle level a été appliqué à pin
   return micros; // au final micro seconde est la durée pour une transition [!level-->level] (--> !level)
}

// Recuperation du temp (en micro secondes) d'une pulsation
// 	--> Si pin pas déjà positionné à <level>, attend, depuis l'appel de cette fonction, le moment ou le pin est positionné à <level>
// 	--> Attend que pin soit repositionné à !<level>
//  --> Retourne la durée pendant laquelle le pin est resté à level (en microseconde), ou bien 0 si trop de temps s'est écoulé

struct HighLowPulse
{
	unsigned long high;
	unsigned long low;
};

typedef struct HighLowPulse t_HighLowPulse;

t_HighLowPulse pulseIn(int pin, int level, int timeout)
{
	t_HighLowPulse result;
	result.high=0;
	result.low=0;

	struct timeval 	tn, 	t0, 	t1;  		// t0 = début d'appel de la fonction, t1 = instant ou 
	long 			tn_us,	t0_us,	t1_us;	// t<i>_us est égal aux variables t0, t1, tn en les convertissant en microseconde : t<i>_us = t<i>.tv_sec * 1000000L + t<i>.tv_usec
	long micros;
	gettimeofday(&t0, NULL);
	t0_us = t0.tv_sec * 1000000L + t0.tv_usec;
	micros = 0;
	// attend jusqu'à ce que pin soit positionné à <level>
	while (digitalRead(pin) != level)
	{
		gettimeofday(&tn, NULL);
		tn_us = tn.tv_sec * 1000000L + tn.tv_usec;
		micros = tn_us - t0_us;
		if (micros > timeout) {	result.low = result.high = 0;	return result;	}
	}
	gettimeofday(&t1, NULL); // t1 est l'instant ou le signal arrive à level
	t1_us = t1.tv_sec * 1000000L + t1.tv_usec;
	result.high = t1_us - t0_us;
	
	// attend jusqu'à ce que pin soit positionné à !<level>
	while (digitalRead(pin) == level)
	{
		gettimeofday(&tn, NULL);
		tn_us = tn.tv_sec * 1000000L + tn.tv_usec;
		result.low = tn_us - t1_us;
		if (result.low > timeout) 	{result.low = result.high = 0; return result;		}
	}
	return result; // au final micro seconde est la durée pour une transition [!level-->level] (--> !level)
}


//Programme principal
int main (int argc, char** argv)
{
	//On passe en temps réel
	scheduler_realtime();
	
	string command;
	string path = "php ";
	//on récupere l'argument 1, qui est le chemin vers le fichier php
	path.append(argv[1]);
	log("Demarrage du programme");
	//on récupere l'argument 2, qui est le numéro de Pin GPIO auquel est connecté le recepteur radio
	pin = atoi(argv[2]);
	//Si on ne trouve pas la librairie wiringPI, on arrête l'execution
    if(wiringPiSetup() == -1)
    {
        log("Librairie Wiring PI introuvable, veuillez lier cette librairie...");
        return -1;
    }else{
    	log("Librairie WiringPI detectee");
    }
    pinMode(pin, INPUT);
	log("Pin GPIO configure en entree");
    log("Attente d'un signal du transmetteur ...");
	
	unsigned long signalBitLowTiming[200];
	t_HighLowPulse signalBitPulseTimings[200];
	unsigned long signalbit[200];
	
	//On boucle pour ecouter les signaux
	for(;;)
    {
    	int i = 0;
		//unsigned long t = 0;
	    //avant dernier byte reçu
		int prevBit = 0;
	    //dernier byte reçu
		int bit = 0;
		
		//mise a zero de l'idenfiant télécommande
	    unsigned long sender = 0;
		//mise a zero du groupe
	    bool group=false;
		//mise a zero de l'etat on/off
	    bool on =false;
		//mise a zero de l'idenfiant de la rangée de bouton
	    unsigned long recipient = 0;
		unsigned long premierVerrou = 0;
		unsigned long pulsedelay = 0;
		float delayTolerance = 0.08f;

		command = path+" ";
		
		t_HighLowPulse pulseTimes;
		pulseTimes = pulseIn(pin, LOW, 1000000L);
		
		//Verrou 1 : avec 1700 c'est pas mal
		// 2750 ca marche pas top
		
		// si la durée était < 2,7ms ou > 2.8ms, alors on considère qu'on n'est pas synchronisé avec l'horloge du signal
		while(  !(pulseTimes.low > 13260 && pulseTimes.low < 13350) && !(pulseTimes.low > 11080 && pulseTimes.low < 11130)  )
		{ 
			pulseTimes = pulseIn(pin, LOW,1000000L);
		}
		log("Verrou 1 detecte");	// i.e qu'un HIGH --> LOW --> début d'un HIGH   se produise sur une durée entre 2.7 et 2.8ms 
		premierVerrou = pulseTimes.low;
		pulsedelay = premierVerrou/31; // On considère dans ce code que c'est le protocole1 (il y a 2 protocoles visiblement 1 où il faut diviser par 31, l'autre par 10 ... je n'en sais pas plus)
		
		cout << " Temp verrou = " << premierVerrou << endl;
		// données
		while(i < 64)
		{
			pulseTimes = pulseIn(pin, LOW, 1000000L);
			//Définition et enregistrement du bit (0 ou 1) et des timings correspondants
	        if(pulseTimes.low > pulsedelay* (1 - delayTolerance) /*300*/ && pulseTimes.low < /*500*/ pulsedelay* (1 + delayTolerance))
			{
				bit = 1;
				signalBitPulseTimings[i].low=pulseTimes.low;
				signalBitPulseTimings[i].high=pulseTimes.high;
				signalBitLowTiming[i]=pulseTimes.low;
				signalbit[i]=bit;
			}
	        else if(pulseTimes.low > 3*pulsedelay - pulsedelay* delayTolerance  /*800*/ && pulseTimes.low < /*1500*/ 3*pulsedelay + pulsedelay* delayTolerance)
			{
				bit = 0;
				signalBitPulseTimings[i].low=pulseTimes.low;
				signalBitPulseTimings[i].high=pulseTimes.high;
				signalBitLowTiming[i]=pulseTimes.low;
				signalbit[i]=bit;
			}
	        else if(pulseTimes.low > premierVerrou-100 && pulseTimes.low < premierVerrou+100) // normalement c'est la syncro de fin
			{
				break;
			}
			else
			{
				cout << " Signal aborted at bit number " << i << " because low pulse not in good delay : LastLowPulse =" << pulseTimes.low << endl;
				i = 0;
				break;
			}
			
	
		//Si les données ont bien été détéctées
		if(i>0)
		{
			cout << " ------- Received signal ";
			unsigned long code = 0;
			for (int k=0;k<i;k++)
			{
				cout << signalbit[k];
				code <<= 1;
				code += signalbit[k];
			}
			cout << " decimal=" << code ;
			if (i==24)
			{
				unsigned long codeGroup = code >> 16;
				unsigned long codeBtn = code >> 8;
				codeBtn = codeBtn - 256* codeGroup;
				unsigned long codeState = code - (256*256)*codeGroup - 256 * codeBtn;
				cout << "   group=" << codeGroup << " btn=" << codeBtn << " state=" << codeState;
			}
			cout << " ------- " << endl;
			
			cout << "Verrou.LowPulseTime=" << premierVerrou;
			for (int k=0;k<i;k++)
			{
				if (k%8==0)		printf("\n");
				printf(" b%02i=(",(k+1));
				printf("%4i,% 4i)", signalBitPulseTimings[k].high, signalBitPulseTimings[k].low);
			}
			cout << endl;
		
			//on construit la commande qui vas envoyer les parametres au PHP
			command.append(longToString(sender));
			if(group) 	{command.append(" on");}
			else			{command.append(" off");}

			if(on)			{command.append(" on");}
			else			{command.append(" off");}
			
			command.append(" "+longToString(recipient));
			
			//Et hop, on envoie tout ça au PHP
			system(command.c_str());
		}
		else 	{log("Aucune donnee...");	}
		delay(100);
    } // fin boucle for
	
	scheduler_standard();
}
